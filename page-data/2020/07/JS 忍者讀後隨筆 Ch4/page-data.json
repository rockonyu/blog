{"componentChunkName":"component---src-templates-posts-tsx","path":"/2020/07/JS 忍者讀後隨筆 Ch4/","result":{"data":{"site":{"siteMetadata":{"title":"Austin Chang"}},"markdownRemark":{"id":"9484de16-caf6-56d4-aed2-73e71391750d","excerpt":"簡單的筆記與紀錄額外參考，原作：忍者：JavaScript  開發技巧探秘 CH4 - 老手看函式：理解函式呼叫 4.1 使用函式隱含引數 除了函式定義中明確指出的參數外，呼叫函式還會傳遞兩個隱含參數： 與 。 現在可以透過 ES…","html":"<p>簡單的筆記與紀錄額外參考，原作：<a href=\"https://www.books.com.tw/products/0010701459\" target=\"_blank\">忍者：JavaScript  開發技巧探秘</a></p>\n<h2>CH4 - 老手看函式：理解函式呼叫</h2>\n<h3>4.1 使用函式隱含引數</h3>\n<p>除了函式定義中明確指出的參數外，呼叫函式還會傳遞兩個隱含參數：<code class=\"language-text\">arguments</code> 與 <code class=\"language-text\">this</code>。</p>\n<ul>\n<li>\n<p>現在可以透過 ES6 的不定參數取代 <code class=\"language-text\">arguments</code> 參數</p>\n<ul>\n<li>嚴格模式下會禁用 <code class=\"language-text\">arguments</code> 作為函式參數的別名</li>\n</ul>\n</li>\n<li><code class=\"language-text\">this</code> 參數指的是與函數呼叫相關聯的物件，通常被稱為函式背景空間 (function context)</li>\n</ul>\n<h3>4.2 呼叫函式</h3>\n<p>呼叫函式的方式對程式運作有很大的影響，關鍵是 <code class=\"language-text\">this</code> 參數會如何被建立？可以使用四種形式呼叫函式：</p>\n<h4>作為函式呼叫</h4>\n<ul>\n<li>作為函式 <code class=\"language-text\">skulk()</code></li>\n<li><code class=\"language-text\">this</code> 的值在普通模式下是全域物件 <code class=\"language-text\">window</code>；嚴格模式下是 <code class=\"language-text\">undefined</code></li>\n</ul>\n<h4>作為方法呼叫</h4>\n<ul>\n<li>作為方法 <code class=\"language-text\">ninja.skulk()</code></li>\n<li><code class=\"language-text\">this</code> 的值指向 <code class=\"language-text\">ninja</code> 物件</li>\n</ul>\n<h4>作為建構器呼叫</h4>\n<ul>\n<li>作為建構函式 <code class=\"language-text\">new Ninja()</code></li>\n<li>使用 <code class=\"language-text\">new</code> 關鍵字會建立一個空的新物件，並以它作為函式背景空間 <code class=\"language-text\">this</code></li>\n<li>建構式回傳物件會被視為整個 <code class=\"language-text\">new</code> 表達式的回傳值</li>\n<li>建構函式回傳 primitive value 會被忽略，返回原先建立的物件</li>\n<li>建構器會使用大寫字母開頭</li>\n</ul>\n<h4>使用 apply 與 call 呼叫</h4>\n<ul>\n<li>經由函式的 <code class=\"language-text\">apply</code> 或 <code class=\"language-text\">call</code> 方法呼叫：<code class=\"language-text\">skulk.call(ninja)</code> 或 <code class=\"language-text\">skulk.apply(ninja)</code></li>\n<li>使用 <code class=\"language-text\">addEventListener</code> 瀏覽器事件處理系統會將函式呼叫的背景空間設為目標元素</li>\n<li><code class=\"language-text\">apply</code> 方法使用一個物件作為 <code class=\"language-text\">this</code> 與陣列作為引數</li>\n<li><code class=\"language-text\">call</code> 方法使用一個物件作為 <code class=\"language-text\">this</code> 與多個數值作為引數</li>\n</ul>\n<h3>4.3 修復函式背景空間的問題</h3>\n<ul>\n<li>使用箭頭函式繞過函式的背景空間</li>\n<li>箭頭函式不會擁有自己的隱含 <code class=\"language-text\">this</code> 參數，而是記住建立時的 <code class=\"language-text\">this</code> 參數值</li>\n<li>如果箭頭函式定義在全域物件實值中，箭頭函式裡 <code class=\"language-text\">this</code> 參數即是全域的 window 物件</li>\n<li>使用函式 <code class=\"language-text\">bind</code> 會建立並回傳新的函式，<code class=\"language-text\">this</code> 參數始終是設定的物件</li>\n</ul>\n<h3>4.4 總結</h3>\n<h3>補充參考</h3>\n<ul>\n<li><a href=\"https://www.notion.so/Chapter4-3af8d9eafe304ed683e8374eca4505ea\">阿福的筆記</a></li>\n<li><a href=\"https://www.coderbridge.com/@waynelee2048/05bf562aae0544989594385ce097b9fb\">阿寬的筆記</a></li>\n</ul>","frontmatter":{"title":"JS 忍者讀後隨筆 CH4","date":"2020/7/12","description":null}}},"pageContext":{"slug":"/2020/07/JS 忍者讀後隨筆 Ch4/","previous":{"fields":{"slug":"/2020/07/JS 忍者讀後隨筆 CH3/"},"frontmatter":{"title":"JS 忍者讀後隨筆 CH3","tags":["JS Ninja"]}},"next":{"fields":{"slug":"/2020/07/JS 忍者讀後隨筆 CH5/"},"frontmatter":{"title":"JS 忍者讀後隨筆 CH5","tags":["JS Ninja"]}}}}}